// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Users {
  name      String?
  id        String    @unique @default(cuid())
  clerkId   String?   @unique
  email     String    @unique
  role      Role      @default(viewer)
  location  Location  @default(Tapion)
  createdAt DateTime  @default(now())
  lastLogin DateTime?

  stockLedger StockLedger[]

  session Sessions[]

  stockRequestsCreated  StockRequest[] @relation("StockRequestRequestedBy")
  stockRequestsReviewed StockRequest[] @relation("StockRequestReviewedBy")
  onboardedAt           DateTime?
}

model Sessions {
  id        String   @default(cuid())
  userId    String   @unique
  user      Users    @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())

  ipAddress String?
  userAgent String
  sessionId String?

  @@index([userId, createdAt])
}

enum Role {
  admin
  inventoryClerk
  labStaff
  orderAgent
  viewer
}

enum Location {
  Tapion
  blueCoral
  manoelStreet
  sunnyAcres
  emCare
  RodneyBay // capitalize should be lower case 
  memberCare
  vieuxFort
  soufriere
  other
}

enum Department {
  Administration
  SpecimenCollection
  heamatology
  Chemistry
  Offlines
  Cytology
  Bacteriology
  SpecialChemistry
}

model Products {
  productId     String    @id @map("productId")
  name          String
  rating        Float?
  stockQuantity Int
  minQuantity   Int?      @default(0)
  reorderPoint  Int?
  category      String?
  unit          String?
  supplier      String?
  expiryDate    DateTime?

  imageUrl   String?
  Department String?

  sku String? @unique

  Sales     Sales[]
  Purchases Purchases[]

  inventory Inventory?

  poItems      PurchaseOrderItem[]
  invoiceItems SupplierInvoiceItem[]
  grnItems     GoodsReceiptItem[]
  stockMoves   StockLedger[]
  createdAt    DateTime?             @default(now())
  updatedAt    DateTime              @default(now()) @updatedAt

  stockRequestLines StockRequestLine[]

  @@map("Products")
}

model Inventory {
  id        String   @id @default(cuid())
  productId String   @unique
  product   Products @relation(fields: [productId], references: [productId])

  stockQuantity Int       @default(0)
  minQuantity   Int       @default(0)
  reorderPoint  Int       @default(0)
  lastCountedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Sale {
  id         Int      @id @default(autoincrement())
  locationId Int
  salesDate  DateTime

  hundredsCount Int @default(0)
  fiftiesCount  Int @default(0)
  twentiesCount Int @default(0)
  tensCount     Int @default(0)
  fivesCount    Int @default(0)

  cashTotal  Decimal @db.Decimal(10, 2)
  grandTotal Decimal @db.Decimal(10, 2)

  creditCardTotal Decimal @default(0) @db.Decimal(10, 2)
  debitCardTotal  Decimal @default(0) @db.Decimal(10, 2)
  chequeTotal     Decimal @default(0) @db.Decimal(10, 2)

  notes     String?
  enteredBy String
  //VerifiedBy String shoul be a reference to a user
  //verifiedAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([locationId, salesDate]) //one Entry Per Day
  @@index([salesDate]) //@@index(locationId, createdAt)
  @@map("dailySales")
}

model SalesAuditLog {
  id         Int      @id @default(autoincrement())
  salesId    Int
  action     String   @db.VarChar(50) //Created, updated, deleted, verified
  columnName String
  oldValue   String
  changedBy  String
  changedAt  DateTime @default(now())

  @@index([salesId])
  @@index([changedAt])
  @@map("sales_audit_log")
}

model Sales {
  saleId      String   @id
  productId   String
  timestamp   DateTime
  quantity    Int
  unitPrice   Float
  totalAmount Float
  product     Products @relation(fields: [productId], references: [productId])
}

model Purchases {
  purchaseId String   @id
  productId  String
  timestamp  DateTime
  quantity   Int
  unitCost   Float
  totalCost  Float
  product    Products @relation(fields: [productId], references: [productId])
}

model Expenses {
  expenseId   String   @id @default(uuid())
  category    String
  amount      Float
  date        DateTime @default(now())
  group       String?
  description String?
  status      String   @default("pending")
}

model SalesSummary {
  salesSummaryId   String   @id
  totalValue       Float
  changePercentage Float?
  date             DateTime
}

model PurchaseSummary {
  purchaseSummaryId String   @id
  totalPurchased    Float
  changePercentage  Float?
  date              DateTime
}

model ExpenseSummary {
  expenseSummaryId  String              @id
  totalExpenses     Float
  date              DateTime
  ExpenseByCategory ExpenseByCategory[]
}

model ExpenseByCategory {
  expenseByCategoryId String         @id
  expenseSummaryId    String
  category            String
  amount              BigInt
  date                DateTime
  expenseSummary      ExpenseSummary @relation(fields: [expenseSummaryId], references: [expenseSummaryId])
}

// Purchases Page Data

// -- ENUMS --//
enum POStatus {
  DRAFT
  APPROVED
  SENT
  PARTIALLY_RECEIVED
  RECEIVED
  CLOSED
}

enum GRNStatus {
  DRAFT
  POSTED
}

enum InvoiceStatus {
  PENDING
  READY_TO_PAY
  PARTIALLY_PAID
  PAID
  OVERDUE
}

model Supplier {
  supplierId String @id @default(cuid())
  name       String
  email      String @unique
  phone      String
  address    String

  purchaseOrders PurchaseOrder[]
  invoices       SupplierInvoice[]
}

model DraftProduct {
  id        String   @id @default(cuid())
  name      String   @unique
  unit      String   @default("")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  poItems      PurchaseOrderItem[]
  invoiceItems SupplierInvoiceItem[]
  grnItems     GoodsReceiptItem[]
}

model PurchaseOrder {
  id         String   @id @default(cuid())
  poNumber   String   @unique
  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [supplierId])

  status    POStatus  @default(DRAFT)
  orderDate DateTime  @default(now())
  dueDate   DateTime?
  notes     String?

  items    PurchaseOrderItem[]
  invoices SupplierInvoice[]
  grns     GoodsReceipt[]
  matches  ThreeWayMatch[]

  subtotal Decimal   @db.Decimal(14, 2)
  tax      Decimal   @db.Decimal(14, 2)
  total    Decimal   @db.Decimal(14, 2)
  payments InvoicePayment[]

  @@index([supplierId])
  @@index([poNumber])
}

model PurchaseOrderItem {
  id   String        @id @default(cuid())
  poId String
  po   PurchaseOrder @relation(fields: [poId], references: [id], onDelete: Cascade)

  productId String
  product   DraftProduct @relation(fields: [productId], references: [id])

  // becomes set the first time you post a GRN line for this draft product
  promotedProductId String?
  promotedProduct   Products? @relation(fields: [promotedProductId], references: [productId])

  description String?
  unit        String?
  quantity    Int
  unitPrice   Decimal @db.Decimal(12, 2)
  lineTotal   Decimal @db.Decimal(14, 2)

  invoiceLines SupplierInvoiceItem[]
  grnLines     GoodsReceiptItem[]

  @@index([poId])
  @@index([productId])
  @@index([promotedProductId])
}

model SupplierInvoice {
  id            String   @id @default(cuid())
  invoiceNumber String
  supplierId    String
  supplier      Supplier @relation(fields: [supplierId], references: [supplierId])

  // OPTIONAL FOR MIGRATION, SHOULD BE REQUIRED LATER
  poId String?
  po   PurchaseOrder? @relation(fields: [poId], references: [id])

  status  InvoiceStatus @default(PENDING)
  date    DateTime      @default(now())
  dueDate DateTime?

  items   SupplierInvoiceItem[]
  matches ThreeWayMatch[]
  amount  Decimal               @db.Decimal(14, 2)

  // 1 invoice -> 0..1 GRN
  goodsReceipt GoodsReceipt?

  payments InvoicePayment[]
  balanceRemaining Decimal? @db.Decimal(14, 2) //leave optional for now but later we will be updating it to not NULL

  @@unique([invoiceNumber, supplierId])
  @@index([poId])
  @@index([supplierId])
}

model SupplierInvoiceItem {
  id        String          @id @default(cuid())
  invoiceId String
  invoice   SupplierInvoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  // keep as-is
  draftProductId String
  draftProduct   DraftProduct @relation(fields: [draftProductId], references: [id])

  // OPTIONAL FOR MIGRATION, SHOULD BE REQUIRED LATER FOR YOUR FLOW
  poItemId String?
  poItem   PurchaseOrderItem? @relation(fields: [poItemId], references: [id])

  // optional: if you already promoted, you can point here too
  productId String?
  product   Products? @relation(fields: [productId], references: [productId])

  description String?
  uom         String?
  quantity    Int
  unitPrice   Decimal @db.Decimal(12, 2)
  lineTotal   Decimal @db.Decimal(14, 2)

  // back-link so GRN lines can map to invoice lines
  grnLines GoodsReceiptItem[]

  // (Optional but recommended) prevent duplicate PO-line entries per invoice
  // Leave OFF during migration if existing data violates it.
  // @@unique([invoiceId, poItemId])

  @@index([invoiceId])
  @@index([poItemId])
  @@index([draftProductId])
  @@index([productId])
}

model GoodsReceipt {
  id        String @id @default(cuid())
  grnNumber String @unique

  // OPTIONAL FOR MIGRATION, SHOULD BE REQUIRED LATER
  poId String?
  po   PurchaseOrder? @relation(fields: [poId], references: [id])

  // invoice comes with shipment, GRN after count (your spec)
  invoiceId String? //make required later
  invoice   SupplierInvoice? @relation(fields: [invoiceId], references: [id]) //make required later 

  date   DateTime  @default(now())
  status GRNStatus @default(DRAFT)

  lines   GoodsReceiptItem[]
  matches ThreeWayMatch[]

  // this enforces 1 invoice -> max 1 GRN
  @@unique([invoiceId])
  @@index([poId])
  @@index([invoiceId])
}

model GoodsReceiptItem {
  id    String       @id @default(cuid())
  grnId String
  grn   GoodsReceipt @relation(fields: [grnId], references: [id], onDelete: Cascade)

  // NEW: direct link to the invoice line that this receipt line is reconciling
  // OPTIONAL FOR MIGRATION, SHOULD BE REQUIRED LATER
  invoiceItemId String?
  invoiceItem   SupplierInvoiceItem? @relation(fields: [invoiceItemId], references: [id])

  // OPTIONAL FOR MIGRATION, SHOULD BE REQUIRED LATER
  poItemId String?
  poItem   PurchaseOrderItem? @relation(fields: [poItemId], references: [id])

  productDraftId String
  product        DraftProduct @relation(fields: [productDraftId], references: [id])

  productId       String?
  promotedProduct Products? @relation(fields: [productId], references: [productId])

  unit        String?
  receivedQty Int
  unitPrice   Decimal @db.Decimal(12, 2)

  // (Optional but recommended) prevent duplicate invoice-line mapping in same GRN
  // @@unique([grnId, invoiceItemId])

  @@index([grnId])
  @@index([invoiceItemId])
  @@index([poItemId])
  @@index([productDraftId])
  @@index([productId])
}

model GrnCounter {
  dateKey   String   @id // "20260126"
  next      Int      @default(1)
  updatedAt DateTime @updatedAt
}

model StockLedger {
  id         String   @id @default(cuid())
  productId  String
  product    Products @relation(fields: [productId], references: [productId])
  sourceType String //"GRN" "ADJUSTMENT"
  SourceId   String
  qtyChange  Int
  memo       String?
  createdAt  DateTime @default(now())

  userId String?
  user   Users?  @relation(fields: [userId], references: [id])

  // beforeQty Int
  // afterQty  Int

  @@index([productId])
  @@index([SourceId, sourceType])
  @@index([userId])
}

enum SourceType {
  GRN
  ADJUSTMENT
  STOCKTAKE
  CORRECTION
}

// -----------
// StockSheet
// ----------

enum StockRequestStatus {
  SUBMITTED
  FULFILLED
  CANCELLED
  IN_REVIEW
}

enum StockLineOutcome {
  PENDING
  GRANTED
  ADJUSTED
  UNAVAILABLE
}

model StockRequest {
  id String @id @default(cuid())

  status StockRequestStatus @default(SUBMITTED)

  // snapshot fields (reliable even if user changes later)
  requestedByName     String
  requestedByEmail    String
  requestedByLocation Location

  // optional relation (matches how your StockLedger does it)
  requestedByUserId String?
  requestedByUser   Users?  @relation("StockRequestRequestedBy", fields: [requestedByUserId], references: [id])

  // review/fulfill metadata
  reviewedByUserId String?
  reviewedByUser   Users?  @relation("StockRequestReviewedBy", fields: [reviewedByUserId], references: [id])

  expectedDeliveryAt DateTime?
  messageToRequester String?

  submittedAt DateTime @default(now())
  updatedAt   DateTime @updatedAt

  lines StockRequestLine[]

  @@index([status])
  @@index([requestedByLocation])
  @@index([requestedByUserId])
}

model StockRequestLine {
  id String @id @default(cuid())

  stockRequestId String
  stockRequest   StockRequest @relation(fields: [stockRequestId], references: [id], onDelete: Cascade)

  productId String
  product   Products @relation(fields: [productId], references: [productId])

  requestedQty Int
  grantedQty   Int? // null until reviewed

  outcome StockLineOutcome @default(PENDING)
  notes   String?

  createdAt DateTime @default(now())

  @@index([stockRequestId])
  @@index([productId])
}

enum MatchStatus {
  DRAFT
  READY_TO_PAY
  //may need to delete payment
  PAID
  VOID
  //APPROVED
  //DISPUTED
}

model ThreeWayMatch {
  id        String @id @default(cuid())
  poId      String
  invoiceId String
  //may need to comment out grnId if one invoice can have multiple grns
  grnId     String

  status MatchStatus @default(DRAFT)

  // totals snapshot
  payableTotal Decimal @default(0)
  currency     String? @default("EXD")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  lines MatchLine[]

  po      PurchaseOrder   @relation(fields: [poId], references: [id])
  invoice SupplierInvoice @relation(fields: [invoiceId], references: [id])
  grn     GoodsReceipt    @relation(fields: [grnId], references: [id])

  @@unique([poId, invoiceId, grnId]) // prevent duplicates
  @@unique([invoiceId])
  @@unique([grnId]) // we leave unique for now but later we will change it if one invoice may come in separate ships to be a bit lineient on the system 
}

model MatchLine {
  id      String @id @default(cuid())
  matchId String

  poItemId      String?
  invoiceItemId String?
  grnLineId     String?

  // snapshot identity
  name String?
  unit String?

  // snapshot values
  poQty        Int      @default(0)
  grnQty       Int      @default(0)
  invUnitPrice Decimal?

  payableQty    Int     @default(0)
  payableAmount Decimal @default(0)

  notes String?

  createdAt DateTime @default(now())

  match ThreeWayMatch @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@index([matchId])
}

model InvoicePayment {
  id String @id @default(cuid())

  invoiceId String
  invoice   SupplierInvoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  poId String?
  po   PurchaseOrder? @relation(fields: [poId], references: [id])

  amount   Decimal @db.Decimal(14, 2)
  currency String? @default("XCD")

  paidAt DateTime @default(now())

  method    String? //cash, cheque, wire..
  reference String? //tax # or receipt #
  status    PaymentStatus @default(POSTED)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()

  //@@unique([invoiceId]) //commented out to support parital invoice payment (multiple rows)
  @@index([poId])
  @@index([paidAt])
}

enum PaymentStatus {
  PARTIALLY_PAID
  POSTED
  VOID
}
