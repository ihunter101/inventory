// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Users {
  name      String?
  id        String    @unique @default(cuid())
  clerkId   String?   @unique
  email     String    @unique
  role      Role      @default(viewer)
  location  Location  @default(Tapion)
  createdAt DateTime  @default(now())
  lastLogin DateTime?

  stockLedger StockLedger[]

  session Sessions[]

  stockRequestsCreated  StockRequest[] @relation("StockRequestRequestedBy")
  stockRequestsReviewed StockRequest[] @relation("StockRequestReviewedBy")
  onboardedAt           DateTime?
}

model Sessions {
  id        String   @default(cuid())
  userId    String   @unique
  user      Users    @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())

  ipAddress String?
  userAgent String
  sessionId String?

  @@index([userId, createdAt])
}

enum Role {
  admin
  inventoryClerk
  labStaff
  orderAgent
  viewer
}

enum Location {
  Tapion
  blueCoral
  manoelStreet
  sunnyAcres
  emCare
  RodneyBay
  memberCare
  vieuxFort
  soufriere
  other
}

enum Department {
  Administration
  SpecimenCollection
  heamatology
  Chemistry
  Offlines
  Cytology
  Bacteriology
  SpecialChemistry
}

model Products {
  productId     String    @id @map("productId")
  name          String
  rating        Float?
  stockQuantity Int
  minQuantity   Int?      @default(0)
  reorderPoint  Int?
  category      String?
  unit          String?
  supplier      String?
  expiryDate    DateTime?

  imageUrl   String?
  Department String?

  sku String? @unique

  Sales     Sales[]
  Purchases Purchases[]

  inventory Inventory?

  poItems      PurchaseOrderItem[]
  invoiceItems SupplierInvoiceItem[]
  grnItems     GoodsReceiptItem[]
  stockMoves   StockLedger[]
  createdAt    DateTime?             @default(now())
  updatedAt    DateTime              @default(now()) @updatedAt

  stockRequestLines StockRequestLine[]

  @@map("Products")
}

model Inventory {
  id        String   @id @default(cuid())
  productId String   @unique
  product   Products @relation(fields: [productId], references: [productId])

  stockQuantity Int       @default(0)
  minQuantity   Int       @default(0)
  reorderPoint  Int       @default(0)
  lastCountedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Sale {
  id         Int      @id @default(autoincrement())
  locationId Int
  salesDate  DateTime

  hundredsCount Int @default(0)
  fiftiesCount  Int @default(0)
  twentiesCount Int @default(0)
  tensCount     Int @default(0)
  fivesCount    Int @default(0)

  cashTotal  Decimal @db.Decimal(10, 2)
  grandTotal Decimal @db.Decimal(10, 2)

  creditCardTotal Decimal @default(0) @db.Decimal(10, 2)
  debitCardTotal  Decimal @default(0) @db.Decimal(10, 2)
  chequeTotal     Decimal @default(0) @db.Decimal(10, 2)

  notes     String?
  enteredBy String
  //VerifiedBy String shoul be a reference to a user
  //verifiedAt DateTime

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([locationId, salesDate]) //one Entry Per Day
  @@index([salesDate]) //@@index(locationId, createdAt)
  @@map("dailySales")
}

model SalesAuditLog {
  id         Int      @id @default(autoincrement())
  salesId    Int
  action     String   @db.VarChar(50) //Created, updated, deleted, verified
  columnName String
  oldValue   String
  changedBy  String
  changedAt  DateTime @default(now())

  @@index([salesId])
  @@index([changedAt])
  @@map("sales_audit_log")
}

model Sales {
  saleId      String   @id
  productId   String
  timestamp   DateTime
  quantity    Int
  unitPrice   Float
  totalAmount Float
  product     Products @relation(fields: [productId], references: [productId])
}

model Purchases {
  purchaseId String   @id
  productId  String
  timestamp  DateTime
  quantity   Int
  unitCost   Float
  totalCost  Float
  product    Products @relation(fields: [productId], references: [productId])
}

model Expenses {
  expenseId   String   @id @default(uuid())
  category    String
  amount      Float
  date        DateTime @default(now())
  group       String?
  description String?
  status      String   @default("pending")
}

model SalesSummary {
  salesSummaryId   String   @id
  totalValue       Float
  changePercentage Float?
  date             DateTime
}

model PurchaseSummary {
  purchaseSummaryId String   @id
  totalPurchased    Float
  changePercentage  Float?
  date              DateTime
}

model ExpenseSummary {
  expenseSummaryId  String              @id
  totalExpenses     Float
  date              DateTime
  ExpenseByCategory ExpenseByCategory[]
}

model ExpenseByCategory {
  expenseByCategoryId String         @id
  expenseSummaryId    String
  category            String
  amount              BigInt
  date                DateTime
  expenseSummary      ExpenseSummary @relation(fields: [expenseSummaryId], references: [expenseSummaryId])
}

// Purchases Page Data

// -- ENUMS --//
enum POStatus {
  DRAFT
  APPROVED
  SENT
  PARTIALLY_RECEIVED
  RECEIVED
  CLOSED
}

enum GRNStatus {
  DRAFT
  POSTED
}

enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
}

model Supplier {
  supplierId String @id @default(cuid())
  name       String
  email      String @unique
  phone      String
  address    String

  purchaseOrders PurchaseOrder[]
  invoices       SupplierInvoice[]
}

model DraftProduct {
  id        String   @id @default(cuid())
  name      String   @unique
  unit      String   @default("")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  poItems       PurchaseOrderItem[]
  supplierItems SupplierInvoiceItem[]
  goodsReciept  GoodsReceiptItem[]
}

model PurchaseOrder {
  id         String   @id @default(cuid())
  poNumber   String   @unique
  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [supplierId])

  status    POStatus  @default(DRAFT)
  orderDate DateTime  @default(now())
  dueDate   DateTime?
  notes     String?

  items    PurchaseOrderItem[]
  invoices SupplierInvoice[] // convenience if you want reverse nav
  grns     GoodsReceipt[]

  subtotal Decimal @db.Decimal(14, 2)
  tax      Decimal @db.Decimal(14, 2)
  total    Decimal @db.Decimal(14, 2)

  @@index([supplierId])
  @@index([poNumber])
}

model PurchaseOrderItem {
  id   String        @id @default(cuid())
  poId String
  po   PurchaseOrder @relation(fields: [poId], references: [id], onDelete: Cascade)

  productId String
  product   DraftProduct @relation(fields: [productId], references: [id])

  promotedProductId String?
  promotedProduct   Products? @relation(fields: [promotedProductId], references: [productId])

  description String?
  unit        String?
  quantity    Int
  unitPrice   Decimal @db.Decimal(12, 2)
  lineTotal   Decimal @db.Decimal(14, 2)

  // âœ… correct back-relations
  invoiceLines SupplierInvoiceItem[]
  grnLines     GoodsReceiptItem[]

  @@index([poId])
  @@index([productId])
  @@index([promotedProductId])
}


model SupplierInvoice {
  id            String   @id @default(cuid())
  invoiceNumber String
  supplierId    String
  supplier      Supplier @relation(fields: [supplierId], references: [supplierId])

  poId String?
  po   PurchaseOrder? @relation(fields: [poId], references: [id]) //optional revamp

  status  InvoiceStatus @default(PENDING)
  date    DateTime      @default(now())
  dueDate DateTime?

  items               SupplierInvoiceItem[]
  amount              Decimal               @db.Decimal(14, 2)
  GoodsReceipt        GoodsReceipt[]

  @@unique([invoiceNumber, supplierId]) // avoid duplicates per supplier
  @@index([poId])
}

model SupplierInvoiceItem {
  id        String          @id @default(cuid())
  invoiceId String
  invoice   SupplierInvoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  draftProductId String
  draftProduct   DraftProduct @relation(fields: [draftProductId], references: [id])

  poItemId String?
  poItem   PurchaseOrderItem? @relation(fields: [poItemId], references: [id])

  productId String?
  product   Products? @relation(fields: [productId], references: [productId])

  description String?
  uom         String?
  quantity    Int
  unitPrice   Decimal @db.Decimal(12, 2)
  lineTotal   Decimal @db.Decimal(14, 2)

  @@index([invoiceId])
  @@index([productId])
  @@index([poItemId])
  @@index([draftProductId])
}

model GoodsReceipt {
  id        String @id @default(cuid())
  grnNumber String @unique

  poId String
  po   PurchaseOrder @relation(fields: [poId], references: [id]) //why?

  invoiceId String?
  invoice   SupplierInvoice? @relation(fields: [invoiceId], references: [id]) //why?

  date   DateTime  @default(now())
  status GRNStatus @default(DRAFT)

  lines GoodsReceiptItem[]

  @@unique([invoiceId])
  @@index([poId])
}

model GoodsReceiptItem {
  id    String       @id @default(cuid())
  grnId String
  Grn   GoodsReceipt @relation(fields: [grnId], references: [id], onDelete: Cascade) //why?

  poItemId String?
  poItem   PurchaseOrderItem? @relation(fields: [poItemId], references: [id])

  productDraftId String
  product        DraftProduct @relation(fields: [productDraftId], references: [id])

  productId       String?
  promotedProduct Products? @relation(fields: [productId], references: [productId])

  unit        String?
  receivedQty Int
  unitPrice   Decimal @db.Decimal(12, 2)

  @@index([grnId])
  @@index([productDraftId])
  @@index([productId])
  @@index([poItemId])
}

model StockLedger {
  id         String   @id @default(cuid())
  productId  String
  product    Products @relation(fields: [productId], references: [productId])
  sourceType String //"GRN" "ADJUSTMENT"
  SourceId   String
  qtyChange  Int
  memo       String?
  createdAt  DateTime @default(now())

  userId String?
  user   Users?  @relation(fields: [userId], references: [id])

  // beforeQty Int
  // afterQty  Int

  @@index([productId])
  @@index([SourceId, sourceType])
  @@index([userId])
}

enum SourceType {
  GRN
  ADJUSTMENT
  STOCKTAKE
  CORRECTION
}

// -----------
// StockSheet
// ----------

enum StockRequestStatus {
  SUBMITTED
  FULFILLED
  CANCELLED
  IN_REVIEW
}

enum StockLineOutcome {
  PENDING
  GRANTED
  ADJUSTED
  UNAVAILABLE
}

model StockRequest {
  id String @id @default(cuid())

  status StockRequestStatus @default(SUBMITTED)

  // snapshot fields (reliable even if user changes later)
  requestedByName     String
  requestedByEmail    String
  requestedByLocation Location

  // optional relation (matches how your StockLedger does it)
  requestedByUserId String?
  requestedByUser   Users?  @relation("StockRequestRequestedBy", fields: [requestedByUserId], references: [id])

  // review/fulfill metadata
  reviewedByUserId String?
  reviewedByUser   Users?  @relation("StockRequestReviewedBy", fields: [reviewedByUserId], references: [id])

  expectedDeliveryAt DateTime?
  messageToRequester String?

  submittedAt DateTime @default(now())
  updatedAt   DateTime @updatedAt

  lines StockRequestLine[]

  @@index([status])
  @@index([requestedByLocation])
  @@index([requestedByUserId])
}

model StockRequestLine {
  id String @id @default(cuid())

  stockRequestId String
  stockRequest   StockRequest @relation(fields: [stockRequestId], references: [id], onDelete: Cascade)

  productId String
  product   Products @relation(fields: [productId], references: [productId])

  requestedQty Int
  grantedQty   Int? // null until reviewed

  outcome StockLineOutcome @default(PENDING)
  notes   String?

  createdAt DateTime @default(now())

  @@index([stockRequestId])
  @@index([productId])
}
